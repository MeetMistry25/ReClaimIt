# ReClaimIt - Important Code Snippets and Explanations
# =====================================================

## Table of Contents
1. Authentication & Token Management
2. Database Models & Schemas
3. API Routes & Controllers
4. Frontend Components
5. Dark Mode Implementation
6. Search Functionality
7. Claim Management System
8. File Upload & Image Handling
9. Error Handling & Validation
10. Environment Configuration

## 1. AUTHENTICATION & TOKEN MANAGEMENT
=====================================

### JWT Token Generation (Backend)
File: server/middleware/authMiddleware.js
```javascript
generateToken: (user) => {
  return jwt.sign(
    { 
      id: user.id, 
      email: user.email, 
      name: user.name 
    },
    JWT_SECRET,
    { expiresIn: '7d' }
  );
}
```
Explanation: Creates a JWT token with user information that expires in 7 days. Used for secure authentication across the application.

### Token Verification (Backend)
File: server/middleware/authMiddleware.js
```javascript
verifyToken: (req, res, next) => {
  const token = req.headers.authorization?.split(' ')[1] || 
                req.cookies?.token || 
                req.query.token;

  if (!token) {
    return res.status(401).json({
      success: false,
      message: 'Access denied. No token provided.'
    });
  }

  try {
    const decoded = jwt.verify(token, JWT_SECRET);
    req.user = decoded;
    next();
  } catch (error) {
    return res.status(401).json({
      success: false,
      message: 'Invalid token.'
    });
  }
}
```
Explanation: Middleware that verifies JWT tokens from headers, cookies, or query parameters. Extracts user information and adds it to the request object.

### Frontend Token Management
File: client/src/contexts/AuthContext.js
```javascript
const verifyToken = async () => {
  if (token) {
    try {
      const response = await fetch(`${API_BASE}/auth/verify`, {
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json',
        },
      });

      if (response.ok) {
        const data = await response.json();
        setUser(data.user);
      } else {
        localStorage.removeItem('token');
        setToken(null);
        setUser(null);
      }
    } catch (error) {
      console.error('Token verification error:', error);
      localStorage.removeItem('token');
      setToken(null);
      setUser(null);
    }
  }
  setLoading(false);
};
```
Explanation: Automatically verifies token validity on app load. If token is invalid, it's removed from localStorage and user is logged out.

## 2. DATABASE MODELS & SCHEMAS
==============================

### User Model
File: server/models/User.js
```javascript
const userSchema = new mongoose.Schema({
  name: { type: String, required: true, trim: true },
  email: { type: String, required: true, unique: true, lowercase: true },
  password: { type: String, required: true, minlength: 6 },
  rollNumber: { type: String, required: true, unique: true },
  branch: { type: String, required: true },
  isActive: { type: Boolean, default: true },
  activeClaims: { type: Number, default: 0 },
  role: { type: String, enum: ['user', 'admin'], default: 'user' }
}, { timestamps: true });
```
Explanation: Defines user schema with validation rules. Includes role-based access control and claim tracking.

### Found Item Model
File: server/models/FoundItem.js
```javascript
const foundItemSchema = new mongoose.Schema({
  userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  itemName: { type: String, required: true, trim: true },
  description: { type: String, required: true, trim: true },
  category: { type: String, required: true, enum: ['Electronics', 'Documents', 'Clothing', 'Accessories', 'Books', 'Keys', 'ID Cards', 'Wallets', 'Others'] },
  placeFound: { type: String, required: true, trim: true },
  dateFound: { type: Date, required: true },
  imageUrl: { type: String, default: null },
  contactInfo: { type: String, required: true },
  pickupLocation: { type: String, default: 'Student Center - Lost & Found Office' },
  status: { type: String, enum: ['active', 'claimed', 'resolved'], default: 'active' },
  claimedBy: { type: mongoose.Schema.Types.ObjectId, ref: 'User', default: null },
  claimedAt: { type: Date, default: null },
  validationQuestions: [{
    question: { type: String, required: true },
    expectedAnswer: { type: String, required: true }
  }],
  isVisible: { type: Boolean, default: true }
}, { timestamps: true });
```
Explanation: Comprehensive schema for found items including validation questions, claim tracking, and visibility control.

### Claim Model
File: server/models/Claim.js
```javascript
const claimSchema = new mongoose.Schema({
  itemId: { type: mongoose.Schema.Types.ObjectId, required: true },
  itemType: { type: String, enum: ['FoundItem', 'LostItem'], required: true },
  claimantId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  answers: [{
    question: { type: String, required: true },
    answer: { type: String, required: true }
  }],
  status: { type: String, enum: ['pending', 'approved', 'declined'], default: 'pending' },
  adminNotes: { type: String, default: '' },
  reviewedBy: { type: mongoose.Schema.Types.ObjectId, ref: 'User', default: null },
  reviewedAt: { type: Date, default: null }
}, { timestamps: true });
```
Explanation: Tracks claim submissions with validation answers, admin review process, and status management.

## 3. API ROUTES & CONTROLLERS
=============================

### Claim Submission Controller
File: server/controllers/claimController.js
```javascript
exports.submitClaim = async (req, res) => {
  try {
    const { itemId, itemType, answers } = req.body;
    const claimantId = req.user.id;

    // Validate item exists
    let item;
    if (itemType === 'FoundItem') {
      item = await FoundItem.findById(itemId);
    } else if (itemType === 'LostItem') {
      item = await LostItem.findById(itemId);
    } else {
      return res.status(400).json({ message: 'Invalid item type' });
    }

    if (!item) {
      return res.status(404).json({ message: 'Item not found' });
    }

    // Check if user already has a pending claim for this item
    const existingClaim = await Claim.findOne({
      itemId,
      claimantId,
      status: 'pending'
    });

    if (existingClaim) {
      return res.status(400).json({ message: 'You already have a pending claim for this item' });
    }

    // Create new claim
    const newClaim = new Claim({
      itemId,
      itemType,
      claimantId,
      answers
    });

    await newClaim.save();

    res.status(201).json({
      success: true,
      message: 'Claim submitted successfully',
      claim: newClaim
    });
  } catch (error) {
    console.error('Error submitting claim:', error);
    res.status(500).json({ message: 'Server error', error: error.message });
  }
};
```
Explanation: Handles claim submission with validation, duplicate checking, and proper error handling.

### Item Visibility Filtering
File: server/data/foundItems.js
```javascript
getAll: async (filters = {}) => {
  try {
    let query = {};
    
    if (filters.category) {
      query.category = filters.category;
    }
    
    if (filters.placeFound) {
      query.placeFound = { $regex: filters.placeFound, $options: 'i' };
    }
    
    if (filters.dateFrom || filters.dateTo) {
      query.dateFound = {};
      if (filters.dateFrom) {
        query.dateFound.$gte = new Date(filters.dateFrom);
      }
      if (filters.dateTo) {
        query.dateFound.$lte = new Date(filters.dateTo);
      }
    }
    
    if (filters.status) {
      query.status = filters.status;
    }

    // Always filter by isVisible: true to hide approved items
    query.isVisible = true;

    const items = await FoundItem.find(query)
      .populate('userId', 'name email rollNumber branch')
      .populate('claimedBy', 'name email rollNumber')
      .sort({ createdAt: -1 });

    return items;
  } catch (error) {
    console.error('Error getting found items:', error);
    throw error;
  }
}
```
Explanation: Filters items to only show visible ones (hides approved/claimed items from public view).

## 4. FRONTEND COMPONENTS
========================

### Search Bar Implementation
File: client/src/components/Navbar.js
```javascript
const handleSearch = (e) => {
  e.preventDefault();
  if (searchQuery.trim()) {
    navigate(`/search?q=${encodeURIComponent(searchQuery.trim())}`);
    setSearchQuery('');
    setIsOpen(false);
  }
};

// Search bar JSX
<form onSubmit={handleSearch} className="w-full max-w-2xl">
  <div className="relative">
    <input
      type="text"
      placeholder="Search items..."
      value={searchQuery}
      onChange={(e) => setSearchQuery(e.target.value)}
      className={navInputClass}
    />
    <MagnifyingGlassIcon className={`absolute left-4 top-3 h-6 w-6 ${navIconClass}`} />
  </div>
</form>
```
Explanation: Implements search functionality with proper form handling and navigation to search results page.

### Claim Submission with Error Handling
File: client/src/pages/ItemDetail.js
```javascript
const handleClaimSubmit = async (e) => {
  e.preventDefault();
  
  if (!user) {
    navigate('/login', { state: { from: `/item/${type}/${id}` } });
    return;
  }
  
  // Validate answers
  const emptyAnswers = claimAnswers.some(a => !a.answer.trim());
  if (emptyAnswers) {
    setClaimError('Please answer all validation questions');
    return;
  }
  
  setSubmitting(true);
  setClaimError(null);
  
  try {
    const token = localStorage.getItem('token');
    
    if (!token) {
      setClaimError('Authentication required. Please login again.');
      navigate('/login', { state: { from: `/item/${type}/${id}` } });
      return;
    }
    
    const response = await fetch('/api/claims/submit', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
      },
      body: JSON.stringify({
        itemId: id,
        itemType: isLost ? 'LostItem' : 'FoundItem',
        answers: claimAnswers
      })
    });
    
    const data = await response.json();
    
    if (!response.ok) {
      if (response.status === 401) {
        // Token is invalid, redirect to login
        localStorage.removeItem('token');
        setClaimError('Session expired. Please login again.');
        setTimeout(() => {
          navigate('/login', { state: { from: `/item/${type}/${id}` } });
        }, 2000);
        return;
      }
      throw new Error(data.message || 'Failed to submit claim');
    }
    
    setClaimSuccess(true);
    setShowClaimModal(false);
  } catch (err) {
    console.error('Claim submission error:', err);
    setClaimError(err.message || 'An error occurred while submitting your claim');
  } finally {
    setSubmitting(false);
  }
};
```
Explanation: Comprehensive claim submission with validation, error handling, and proper token management.

## 5. DARK MODE IMPLEMENTATION
============================

### Dark Mode Toggle
File: client/src/components/Navbar.js
```javascript
const [isDark, setIsDark] = useState(false);

// On mount, set theme from localStorage or system preference
useEffect(() => {
  const savedTheme = localStorage.getItem('theme');
  if (savedTheme === 'dark') {
    setIsDark(true);
    document.documentElement.classList.add('dark');
  } else if (savedTheme === 'light') {
    setIsDark(false);
    document.documentElement.classList.remove('dark');
  } else {
    // System preference
    const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
    setIsDark(prefersDark);
    if (prefersDark) {
      document.documentElement.classList.add('dark');
    } else {
      document.documentElement.classList.remove('dark');
    }
  }
}, []);

// Handle toggle
const handleThemeToggle = (e) => {
  const checked = e.target.checked;
  setIsDark(checked);
  if (checked) {
    document.documentElement.classList.add('dark');
    localStorage.setItem('theme', 'dark');
  } else {
    document.documentElement.classList.remove('dark');
    localStorage.setItem('theme', 'light');
  }
};
```
Explanation: Implements dark mode toggle with localStorage persistence and system preference detection.

### Dark Mode CSS Classes
File: client/src/pages/admin/ClaimsManagement.js
```javascript
// Example of dark mode styling
<div className="container mx-auto p-4 dark:bg-gray-900 dark:text-gray-100">
  <h1 className="text-2xl font-bold mb-6 dark:text-white">Claims Management</h1>
  
  <div className="flex border-b border-gray-200 dark:border-gray-700 mb-6">
    <button className={`py-2 px-4 ${
      activeTab === 'pending' 
        ? 'border-b-2 border-blue-500 text-blue-500 dark:text-blue-400' 
        : 'text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-300'
    }`}>
      Pending Claims
    </button>
  </div>
  
  <table className="min-w-full bg-white dark:bg-gray-800 rounded-lg shadow-sm">
    <thead>
      <tr className="bg-gray-100 dark:bg-gray-700">
        <th className="py-2 px-4 text-left text-gray-900 dark:text-gray-100">Item</th>
      </tr>
    </thead>
  </table>
</div>
```
Explanation: Shows how to implement dark mode classes with proper contrast and hover states.

## 6. SEARCH FUNCTIONALITY
=========================

### Search Results Filtering
File: client/src/pages/Search.js
```javascript
// Filter to only show found items with images
const foundItemsWithImages = (results.foundItems || []).filter(item => 
  item.imageUrl && item.imageUrl.trim() !== ''
);
const totalResults = foundItemsWithImages.length;

const filteredResults = foundItemsWithImages;
```
Explanation: Filters search results to only show found items that have images, improving user experience.

### Search API Implementation
File: server/controllers/itemController.js
```javascript
searchItems: async (req, res) => {
  try {
    const { keyword, type = 'both' } = req.query;
    
    if (!keyword) {
      return res.status(400).json({
        success: false,
        message: 'Search keyword is required'
      });
    }

    let results = {};

    if (type === 'lost' || type === 'both') {
      results.lostItems = await lostItemsService.search(keyword);
    }

    if (type === 'found' || type === 'both') {
      results.foundItems = await foundItemsService.search(keyword);
    }

    res.json({
      success: true,
      results,
      totalCount: (results.lostItems?.length || 0) + (results.foundItems?.length || 0)
    });
  } catch (error) {
    console.error('Search items error:', error);
    res.status(500).json({
      success: false,
      message: 'Error searching items'
    });
  }
}
```
Explanation: Handles search requests with keyword validation and returns results from both lost and found items.

## 7. CLAIM MANAGEMENT SYSTEM
============================

### Admin Claim Approval
File: server/controllers/claimController.js
```javascript
exports.approveClaim = async (req, res) => {
  try {
    const { claimId } = req.params;
    const { adminNotes } = req.body;
    const adminId = req.user.id;

    const claim = await Claim.findById(claimId);
    if (!claim) {
      return res.status(404).json({ message: 'Claim not found' });
    }

    if (claim.status !== 'pending') {
      return res.status(400).json({ message: 'Claim is not pending' });
    }

    // Update claim status
    claim.status = 'approved';
    claim.adminNotes = adminNotes || '';
    claim.reviewedBy = adminId;
    claim.reviewedAt = Date.now();
    await claim.save();

    // Update item status and visibility
    let item;
    if (claim.itemType === 'FoundItem') {
      item = await FoundItem.findById(claim.itemId);
      if (item) {
        item.status = 'claimed';
        item.claimedBy = claim.claimantId;
        item.claimedAt = Date.now();
        item.isVisible = false; // Hide from public view
        await item.save();
      }
    } else if (claim.itemType === 'LostItem') {
      item = await LostItem.findById(claim.itemId);
      if (item) {
        item.status = 'claimed';
        item.claimedBy = claim.claimantId;
        item.claimedAt = Date.now();
        item.isVisible = false; // Hide from public view
        await item.save();
      }
    }

    // Send email notification (optional)
    try {
      await transporter.sendMail(mailOptions);
      console.log('Email notification sent successfully');
    } catch (emailError) {
      console.log('Email notification failed (email not configured):', emailError.message);
    }

    res.json({ message: 'Claim approved successfully' });
  } catch (error) {
    console.error('Error approving claim:', error);
    res.status(500).json({ message: 'Server error', error: error.message });
  }
};
```
Explanation: Handles claim approval with item status updates, visibility control, and email notifications.

## 8. FILE UPLOAD & IMAGE HANDLING
==================================

### Multer Configuration
File: server/middleware/upload.js
```javascript
const multer = require('multer');
const path = require('path');

const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, 'uploads/');
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));
  }
});

const fileFilter = (req, file, cb) => {
  if (file.mimetype.startsWith('image/')) {
    cb(null, true);
  } else {
    cb(new Error('Only image files are allowed!'), false);
  }
};

const upload = multer({
  storage: storage,
  limits: {
    fileSize: 5 * 1024 * 1024 // 5MB limit
  },
  fileFilter: fileFilter
});

module.exports = upload;
```
Explanation: Configures multer for file uploads with size limits, file type validation, and unique naming.

### Frontend Image Upload
File: client/src/pages/ReportFoundItem.js
```javascript
const handleImageChange = (e) => {
  setForm(prev => ({ 
    ...prev, 
    images: Array.from(e.target.files) 
  }));
};

// In form submission
const formData = new FormData();
formData.append('itemName', form.itemName);
formData.append('description', form.description);
formData.append('category', selectedCategory);
formData.append('placeFound', form.location);
formData.append('dateFound', form.date);
formData.append('pickupLocation', form.pickupLocation);

if (form.images && form.images.length > 0) {
  formData.append('image', form.images[0]); // Backend expects single image
}

const response = await fetch('/api/items/found', {
  method: 'POST',
  headers: {
    'Authorization': `Bearer ${localStorage.getItem('token')}`
  },
  body: formData
});
```
Explanation: Handles image file selection and upload using FormData with proper authentication headers.

## 9. ERROR HANDLING & VALIDATION
=================================

### Global Error Handler
File: server/server.js
```javascript
// Global error handler
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).json({
    success: false,
    message: 'Something went wrong!',
    error: process.env.NODE_ENV === 'development' ? err.message : 'Internal server error'
  });
});

// Handle 404 routes
app.use('*', (req, res) => {
  res.status(404).json({
    success: false,
    message: 'Route not found'
  });
});
```
Explanation: Centralized error handling with environment-specific error messages and 404 route handling.

### Frontend Error Boundary
File: client/src/contexts/AuthContext.js
```javascript
const login = async (email, password) => {
  try {
    const response = await fetch(`${API_BASE}/auth/login`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ email, password }),
    });

    const data = await response.json();

    if (!response.ok) {
      throw new Error(data.message || 'Login failed');
    }

    setToken(data.token);
    setUser(data.user);
    localStorage.setItem('token', data.token);
    return { success: true };
  } catch (error) {
    console.error('Login error:', error);
    return { success: false, error: error.message };
  }
};
```
Explanation: Proper error handling in async functions with try-catch blocks and meaningful error messages.

## 10. ENVIRONMENT CONFIGURATION
================================

### Environment Variables
File: server/.env
```
MONGODB_URI=mongodb://localhost:27017/reclaimit
JWT_SECRET=your-super-secret-jwt-key-change-in-production
EMAIL_USER=your-email@gmail.com
EMAIL_PASSWORD=your-app-password
NODE_ENV=development
```

### Database Connection
File: server/server.js
```javascript
const mongoose = require('mongoose');
require('dotenv').config();

mongoose.connect(process.env.MONGODB_URI || 'mongodb://localhost:27017/reclaimit', {
  useNewUrlParser: true,
  useUnifiedTopology: true,
})
.then(() => console.log('✅ Connected to MongoDB'))
.catch(err => console.error('❌ MongoDB connection error:', err));
```
Explanation: Secure database connection using environment variables with fallback defaults.

## KEY FEATURES IMPLEMENTED
===========================

1. **Authentication System**: JWT-based authentication with role-based access control
2. **Item Management**: Complete CRUD operations for lost and found items
3. **Claim System**: Validation questions, admin approval workflow
4. **Search Functionality**: Full-text search with filtering and image display
5. **Dark Mode**: Complete dark mode implementation across all components
6. **File Upload**: Image upload with validation and storage
7. **Email Notifications**: Automated email alerts for claim status changes
8. **Responsive Design**: Mobile-first responsive design with Tailwind CSS
9. **Error Handling**: Comprehensive error handling and user feedback
10. **Security**: Input validation, SQL injection prevention, secure file uploads

## DEPLOYMENT NOTES
==================

1. **Environment Variables**: Ensure all required environment variables are set
2. **Database**: MongoDB instance must be running and accessible
3. **File Uploads**: Ensure uploads directory exists and has proper permissions
4. **Email Service**: Configure email service for notifications (optional)
5. **CORS**: Configure CORS settings for production domains
6. **HTTPS**: Use HTTPS in production for secure token transmission

## TROUBLESHOOTING COMMON ISSUES
================================

1. **Token Errors**: Check JWT_SECRET consistency and token expiration
2. **Database Connection**: Verify MongoDB URI and network connectivity
3. **File Uploads**: Check multer configuration and file permissions
4. **CORS Issues**: Verify allowed origins in CORS configuration
5. **Email Failures**: Check email service credentials and configuration

This documentation covers the most critical code snippets and their explanations for the ReClaimIt application. Each snippet includes context about its purpose and how it fits into the overall system architecture.
